"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var error_1 = require("../error");
var base_1 = require("../base");
var alg_1 = require("../alg");
var Hmac = (function (_super) {
    __extends(Hmac, _super);
    function Hmac() {
        _super.apply(this, arguments);
    }
    Hmac.checkAlgorithm = function (alg) {
        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
            throw new error_1.AlgorithmError(error_1.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
    };
    Hmac.checkKeyGenParams = function (alg) {
        // length is optional
        if ("length" in alg && !(alg.length > 0 && alg.length <= 512)) {
            throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_WRONG_VALUE, "length", "more 0 and less than 512");
        }
    };
    Hmac.checkKeyGenUsages = function (keyUsages) {
        var _this = this;
        this.checkKeyUsages(keyUsages);
        keyUsages.forEach(function (usage) {
            var i = 0;
            for (i; i < _this.KEY_USAGES.length; i++)
                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                    break;
                }
            if (i === _this.KEY_USAGES.length)
                throw new error_1.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + _this.KEY_USAGES.join(", ") + "]");
        });
    };
    Hmac.generateKey = function (algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithm(algorithm);
            _this.checkKeyGenParams(algorithm);
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    Hmac.exportKey = function (format, key) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkKey(key, _this.ALG_NAME);
            _this.checkFormat(format, key.type);
            resolve(undefined);
        });
    };
    Hmac.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithm(algorithm);
            _this.checkFormat(format);
            if (!(format.toLowerCase() === "raw" || format.toLowerCase() === "jwk"))
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.ALLOWED_FORMAT, format, "'jwk' or 'raw'");
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    Hmac.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "secret", "sign");
            resolve(undefined);
        });
    };
    Hmac.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "secret", "verify");
            resolve(undefined);
        });
    };
    Hmac.ALG_NAME = alg_1.AlgorithmNames.Hmac;
    Hmac.KEY_USAGES = ["sign", "verify"];
    return Hmac;
}(base_1.BaseCrypto));
exports.Hmac = Hmac;
