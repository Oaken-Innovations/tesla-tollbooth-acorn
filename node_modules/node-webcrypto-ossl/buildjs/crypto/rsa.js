"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto = require("webcrypto-core");
var WebCryptoError = webcrypto.WebCryptoError;
var BaseCrypto = webcrypto.BaseCrypto;
var Base64Url = webcrypto.Base64Url;
var key_1 = require("../key");
var native = require("../native");
function b64_decode(b64url) {
    return new Buffer(Base64Url.decode(b64url));
}
var RsaCrypto = (function (_super) {
    __extends(RsaCrypto, _super);
    function RsaCrypto() {
        _super.apply(this, arguments);
    }
    RsaCrypto.generateKey = function (algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var size = algorithm.modulusLength;
            var exp = new Buffer(algorithm.publicExponent);
            var nExp = 0;
            if (exp.length === 3)
                nExp = 1;
            native.Key.generateRsa(size, nExp, function (err, key) {
                try {
                    if (err) {
                        reject(new WebCryptoError("Rsa: Can not generate new key\n" + err.message));
                    }
                    else {
                        var prvUsages = ["sign", "decrypt", "unwrapKey"]
                            .filter(function (usage) { return keyUsages.some(function (keyUsage) { return keyUsage === usage; }); });
                        var pubUsages = ["verify", "encrypt", "wrapKey"]
                            .filter(function (usage) { return keyUsages.some(function (keyUsage) { return keyUsage === usage; }); });
                        resolve({
                            privateKey: new key_1.CryptoKey(key, algorithm, "private", extractable, prvUsages),
                            publicKey: new key_1.CryptoKey(key, algorithm, "public", extractable, pubUsages)
                        });
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    };
    RsaCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _format = format.toLocaleLowerCase();
            switch (_format) {
                case "jwk":
                    var jwk = keyData;
                    var data = {};
                    var alg_1 = algorithm;
                    data["kty"] = jwk.kty;
                    data["n"] = b64_decode(jwk.n);
                    data["e"] = b64_decode(jwk.e);
                    var key_type_1 = native.KeyType.PUBLIC;
                    if (jwk.d) {
                        key_type_1 = native.KeyType.PRIVATE;
                        data["d"] = b64_decode(jwk.d);
                        data["p"] = b64_decode(jwk.p);
                        data["q"] = b64_decode(jwk.q);
                        data["dp"] = b64_decode(jwk.dp);
                        data["dq"] = b64_decode(jwk.dq);
                        data["qi"] = b64_decode(jwk.qi);
                    }
                    native.Key.importJwk(data, key_type_1, function (err, key) {
                        try {
                            if (err)
                                reject(new WebCryptoError("ImportKey: Cannot import key from JWK\n" + err));
                            else {
                                var rsa = new key_1.CryptoKey(key, alg_1, key_type_1 ? "private" : "public", extractable, keyUsages);
                                resolve(rsa);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                case "pkcs8":
                case "spki":
                    if (!Buffer.isBuffer(keyData))
                        throw new WebCryptoError("ImportKey: keyData is not a Buffer");
                    var importFunction = native.Key.importPkcs8;
                    if (_format === "spki")
                        importFunction = native.Key.importSpki;
                    importFunction(keyData, function (err, key) {
                        try {
                            if (err)
                                reject(new WebCryptoError("ImportKey: Can not import key for " + format + "\n" + err.message));
                            else {
                                var rsa = new key_1.CryptoKey(key, alg_1, format.toLocaleLowerCase() === "spki" ? "public" : "private", extractable, keyUsages);
                                resolve(rsa);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                default:
                    throw new WebCryptoError("ImportKey: Wrong format value '" + format + "'");
            }
        });
    };
    RsaCrypto.exportKey = function (format, key) {
        return new Promise(function (resolve, reject) {
            var nkey = key.native;
            var type = key.type === "public" ? native.KeyType.PUBLIC : native.KeyType.PRIVATE;
            switch (format.toLocaleLowerCase()) {
                case "jwk":
                    nkey.exportJwk(type, function (err, data) {
                        try {
                            var jwk = { kty: "RSA" };
                            jwk.key_ops = key.usages;
                            jwk.e = Base64Url.encode(data.e);
                            jwk.n = Base64Url.encode(data.n);
                            if (key.type === "private") {
                                jwk.d = Base64Url.encode(data.d);
                                jwk.p = Base64Url.encode(data.p);
                                jwk.q = Base64Url.encode(data.q);
                                jwk.dp = Base64Url.encode(data.dp);
                                jwk.dq = Base64Url.encode(data.dq);
                                jwk.qi = Base64Url.encode(data.qi);
                            }
                            resolve(jwk);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                case "spki":
                    nkey.exportSpki(function (err, raw) {
                        if (err)
                            reject(err);
                        else
                            resolve(raw.buffer);
                    });
                    break;
                case "pkcs8":
                    nkey.exportPkcs8(function (err, raw) {
                        if (err)
                            reject(err);
                        else
                            resolve(raw.buffer);
                    });
                    break;
                default:
                    throw new WebCryptoError("ExportKey: Unknown export format '" + format + "'");
            }
        });
    };
    RsaCrypto.wc2ssl = function (alg) {
        var _alg = alg.hash.name.toUpperCase().replace("-", "");
        return _alg;
    };
    return RsaCrypto;
}(BaseCrypto));
exports.RsaCrypto = RsaCrypto;
var RsaPKCS1 = (function (_super) {
    __extends(RsaPKCS1, _super);
    function RsaPKCS1() {
        _super.apply(this, arguments);
    }
    RsaPKCS1.exportKey = function (format, key) {
        return _super.exportKey.call(this, format, key)
            .then(function (jwk) {
            if (format === "jwk") {
                var reg = /(\d+)$/;
                jwk.alg = "RS" + reg.exec(key.algorithm.hash.name)[1];
                jwk.ext = true;
                if (key.type === "public") {
                    jwk.key_ops = ["verify"];
                }
            }
            return jwk;
        });
    };
    RsaPKCS1.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(key.algorithm);
            var nkey = key.native;
            nkey.sign(_alg, data, function (err, signature) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else {
                    resolve(signature.buffer);
                }
            });
        });
    };
    RsaPKCS1.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(key.algorithm);
            var nkey = key.native;
            nkey.verify(_alg, data, signature, function (err, res) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else
                    resolve(res);
            });
        });
    };
    return RsaPKCS1;
}(RsaCrypto));
exports.RsaPKCS1 = RsaPKCS1;
var RsaPSS = (function (_super) {
    __extends(RsaPSS, _super);
    function RsaPSS() {
        _super.apply(this, arguments);
    }
    RsaPSS.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(key.algorithm);
            var nkey = key.native;
            nkey.RsaPssSign(_alg, _alg.saltLength / 8, data, function (err, signature) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else
                    resolve(signature.buffer);
            });
        });
    };
    RsaPSS.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(key.algorithm);
            var nkey = key.native;
            nkey.RsaPssVerify(_alg, _alg.saltLength / 8, data, signature, function (err, res) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else
                    resolve(res);
            });
        });
    };
    RsaPSS.exportKey = function (format, key) {
        return _super.exportKey.call(this, format, key)
            .then(function (jwk) {
            if (format === "jwk") {
                var reg = /(\d+)$/;
                jwk.alg = "PS" + reg.exec(key.algorithm.hash.name)[1];
                jwk.ext = true;
                if (key.type === "public") {
                    jwk.key_ops = ["verify"];
                }
            }
            return jwk;
        });
    };
    return RsaPSS;
}(RsaCrypto));
exports.RsaPSS = RsaPSS;
var RsaOAEP = (function (_super) {
    __extends(RsaOAEP, _super);
    function RsaOAEP() {
        _super.apply(this, arguments);
    }
    RsaOAEP.exportKey = function (format, key) {
        return _super.exportKey.call(this, format, key)
            .then(function (jwk) {
            if (format === "jwk") {
                jwk.alg = "RSA-OAEP";
                var md_size = /(\d+)$/.exec(key.algorithm.hash.name)[1];
                if (md_size !== "1") {
                    jwk.alg += "-" + md_size;
                }
                jwk.ext = true;
                if (key.type === "public") {
                    jwk.key_ops = ["encrypt", "wrapKey"];
                }
                else {
                    jwk.key_ops = ["decrypt", "unwrapKey"];
                }
            }
            return jwk;
        });
    };
    RsaOAEP.EncryptDecrypt = function (algorithm, key, data, type) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(key.algorithm);
            var nkey = key.native;
            var label = null;
            if (algorithm.label) {
                label = new Buffer(algorithm.label);
            }
            nkey.RsaOaepEncDec(_alg, data, label, type, function (err, res) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err));
                else
                    resolve(res.buffer);
            });
        });
    };
    RsaOAEP.encrypt = function (algorithm, key, data) {
        return this.EncryptDecrypt(algorithm, key, data, false);
    };
    RsaOAEP.decrypt = function (algorithm, key, data) {
        return this.EncryptDecrypt(algorithm, key, data, true);
    };
    return RsaOAEP;
}(RsaCrypto));
exports.RsaOAEP = RsaOAEP;
